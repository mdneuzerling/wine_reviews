---
title: "Wine reviews"
author: "mdneuzerling"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)

set.seed(754804) # Chosen by fair dice roll. Guaranteed to be random.
 
library(tidyverse)
library(rvest)
library(kableExtra)
library(e1071)
library(visdat)
library(naniar)
library(tidytext)
library(wordcloud)
data("stop_words")

wine <- "wine_reviews.csv" %>% 
    read_csv %>% 
    mutate(variety = variety %>% tolower)
```

## Incomplete data

From the data viusalisation below, we can see that the price data for the wine
is incomplete. Approximately `r round(100 * prop_miss(wine$price))`% of the 
price values are missing. The other missing values are actually empty strings.
Interestingly, a data frame doesn't treat these as missing by default, but a 
tibble does.

```{r vis_dat, cache = TRUE}
wine %>% sample_n(30000) %>% vis_dat
```

We might be tempted to say that the rest of our data is complete. However, many
values are empty strings. If we replace these empty strings with `NA`, we can
see how incomplete the data really is. Fortunately, not all of these variables
will be useful in predicting wine quality (for example, `taster_twitter_handle`).

## Grape colours

In order to classify the wines as red, white or rosé, we're going to scrape
wine data from the [List of grape varieties](https://en.wikipedia.org/wiki/List_of_grape_varieties)
Wikipedia page, using the `rvest` package. The first three tables of this page
give red, white and rosé wines, in that order.

```{r grape_colours_wiki_scrape, message = FALSE}
wiki_tables <- "https://en.wikipedia.org/wiki/List_of_grape_varieties" %>% 
    read_html %>% 
    html_nodes("table")
red_wines <- wiki_tables[[1]] %>% html_table %>% cbind(colour = "red")
white_wines <- wiki_tables[[2]] %>% html_table %>% cbind(colour = "white")
rose_wines <- wiki_tables[[3]] %>% html_table %>% cbind(colour = "rosé")
all_wines <- rbind(red_wines, white_wines, rose_wines)
```    

We're interested in three columns here: `Common Name(s)`, `All Synonyms` and
the `colour` column we defined from the table scraping. We're also going to 
record `Country of origin` while the opportunity presents itself.

The synonyms are comma-separated strings, ending with periods. Some wines can
also have multiple common names, eg. "Shiraz / Syrah". We're going to rename the
columns to match the tidyverse style, combine the common names and synonyms into
a single `variety` column, and then `unnest` the `variety` column so that each
common name or synonym is on its own line. Finally we're going to clean the 
table so that all entries are in lower-case, the results are distinct, and
certain stray bits of punctuation are removed.

```{r grape_colours_cleaning, message = FALSE}
variety_colours <- all_wines %>% 
    rename(
        variety = `Common Name(s)`,
        synonyms = `All Synonyms`,
        country_of_origin = `Country of origin`
    ) %>% 
    select(variety, synonyms, country_of_origin, colour) %>% 
    {rbind(
        select(., variety, country_of_origin, colour),
        rename(select(., synonyms, country_of_origin, colour),
               variety = synonyms)
    )} %>%
    unnest(variety = strsplit(variety, ", ")) %>% # split the synonyms into multiple rows
    unnest(variety = strsplit(variety, " / ")) %>% # and again
    mutate(
        variety = gsub("\\.", "", variety), # remove periods 
        variety = gsub("\\s*\\([^\\)]+\\)", "", variety), # remove brackets and anything within
        variety = gsub("\\s*\\[[^\\)]+\\]", "", variety) # same for square brackets
    ) %>% 
    mutate_all(tolower) %>% 
    select(variety, colour, country_of_origin) %>% 
    arrange(variety) %>% 
    distinct
```    

The end result is `r nrow(varieties)` rows, with plenty of repeated entries to 
accommodate for multiple names or variations in spelling.

Now we join the colours with the wine data. If there are any missing values, we 
can attempt to fill them in based on obvious clues in the variety (eg. a "Red 
blend" can safely be assumed to be a red wine).

```{r}
wine_colours <- wine %>% merge(
    variety_colours %>% select(variety, colour),
    by = "variety",
    all = TRUE
) %>% 
    mutate(
        colour = case_when(
            !is.na(colour) ~ colour,
            grepl("sparkling", variety, ignore.case = TRUE) ~ "white",
            grepl("champagne", variety, ignore.case = TRUE) ~ "white",
            grepl("red", variety, ignore.case = TRUE) ~ "red",
            grepl("white", variety, ignore.case = TRUE) ~ "white",
            grepl("rosé", variety, ignore.case = TRUE) ~ "rosé",
            grepl("rose", variety, ignore.case = TRUE) ~ "rosé",
            grepl("port", variety, ignore.case = TRUE) ~ "red" # technically?
        )
    )

wine_colours %>% 
    count(colour) %>% 
    knitr::kable(format = "html") %>% 
    kable_styling(full_width = F)
```

We still have some colours missing. The below suggests that blends are an issue:

```{r missing_colours}
wine_colours %>% 
    filter(is.na(colour)) %>% 
    count(variety, sort = TRUE) %>% 
    head(10) %>% 
    knitr::kable(format = "html") %>% 
    kable_styling(full_width = F)
```

We operate under the assumption that if multiple wines are listed, the first
wine determines the colour. For example, cabernet is red and sauvignon is white,
but cabernet sauvignon is red. We try to classify the unclassified wines again
but using only the first word in their varieties. We split the variety by either
spaces or dashes.

```{r blend_classification}
blend_colours <- 
    wine_colours %>% 
    filter(is.na(colour)) %>% 
    select(variety) %>% 
    rowwise %>% 
    mutate(first_variety = unlist(strsplit(variety, "\\-|\\ | "))[1]) %>% 
    merge(variety_colours, by.x = "first_variety", by.y = "variety") %>% 
    select(variety, colour)
```

Now we can rebuild the wine colours using these new blend results:

```{r}
wine_colours <- wine %>% merge(
    variety_colours %>% select(variety, colour) %>% rbind(blend_colours),
    by = "variety",
    all = TRUE
) %>% 
    mutate(
        colour = case_when(
            !is.na(colour) ~ colour,
            grepl("sparkling", variety, ignore.case = TRUE) ~ "white",
            grepl("champagne", variety, ignore.case = TRUE) ~ "white",
            grepl("red", variety, ignore.case = TRUE) ~ "red",
            grepl("white", variety, ignore.case = TRUE) ~ "white",
            grepl("rosé", variety, ignore.case = TRUE) ~ "rosé",
            grepl("rose", variety, ignore.case = TRUE) ~ "rosé",
            grepl("port", variety, ignore.case = TRUE) ~ "red" # technically?
        )
    )

wine_colours %>% 
    count(colour) %>% 
    knitr::kable(format = "html") %>% 
    kable_styling(full_width = F)
```

## Points
```{r points}
wine %>% ggplot(aes(x = points)) + 
    geom_histogram(
        bins = nrow(wine %>% distinct(points)),
        colour = "white",
        fill = "#AD1037"
    )
```


## Text analysis

Each wine is accompanied by a single-paragraph review. Using the tidytext 
package we can investigate word and n-gram frequency of these reviews. We first
break down the review into single words.

```{r cache = TRUE}
wine_words <- wine %>% 
    unnest_tokens(word, description) %>% 
    anti_join(stop_words, by = "word") %>% 
    filter(word != "wine")
```

We can now generate a simple plot of the ten most commonly occurring words. Some
words, such as "the" and "a", occur frequently and serve only a grammatical
purpose, and so are excluded. We also exclude the word "wine", since the presence
of this word doesn't tell us much about the review.

```{r}
wine_words %>%
    count(word, sort = TRUE) %>%
    head(20) %>%
    mutate(word = reorder(word, n)) %>%
    ggplot(aes(word, n)) +
    geom_col(fill = "#AD1037") +
    xlab(NULL) +
    theme(text = element_text(size=16)) +
    coord_flip()
```

I'm not sure what purpose word clouds serve, but they seem mandatory at this
point.

```{r}
wine_words %>%
  count(word) %>%
  with(wordcloud(word, n, max.words = 100))
```

An n-gram is a tuple of words appearing sequentially in order within an 
utterance. For example, in the utterance "My name is Fred", "is Fred" is a 
2-gram and "name is Fred" is a 3-gram. A word could also be considered as a
1-gram. Below we define the 2-grams (bigrams) and 3-grams (trigrams) of the wine 
descriptions. 

Along with the `ngram` column, the `separate` column provides us
with separate columns for each word in the n-gram. The column names for these
words are dynamically generated in the `wine_ngrams` helper function, which
provides outputs a tibble of n-grams for a given n. We then use these new
word columns to filter out the stop words, although this time we include n-grams
with the word "wine".

```{r cache = TRUE}
wine_ngrams <- function(n) {
    wine %>%  
        unnest_tokens(ngram, description, token = "ngrams", n = n) %>% 
        separate(
            ngram, 
            sapply(1:n, function(x) {paste0("word", x)}), # eg, "word1", "word2" 
            sep = " ",
            remove = FALSE # keep the n-gram in the tibble
        )
}

wine_2grams <- wine_ngrams(2) %>% 
    filter(!word1 %in% stop_words$word) %>%
    filter(!word2 %in% stop_words$word)
wine_3grams <- wine_ngrams(3) %>% 
    filter(!word1 %in% stop_words$word) %>%
    filter(!word2 %in% stop_words$word) %>% 
    filter(!word3 %in% stop_words$word)
```

There are `r nrow(wine_2grams)` 2-grams, taking up around 
`r round(as.numeric(object.size(wine_2grams)) / 1024^2)` megabytes of memory, 
and `r nrow(wine_3grams)` 3-grams, taking up around 
`r round(as.numeric(object.size(wine_3grams)) / 1024^2)` megabytes. The drop in
number and size is due to the filtering of the stop words.

We can also plot the frequency of the 2- and 3-grams:

```{r}
plot_ngram_frequency <- function(x) {
    get(paste0("wine_", x, "grams")) %>%
        count(ngram, sort = TRUE) %>%
        head(20) %>%
        mutate(ngram = reorder(ngram, n)) %>%
        ggplot(aes(ngram, n)) +
        geom_col(fill = "#AD1037") +
        xlab(NULL) +
        theme(text = element_text(size=16)) +
        coord_flip() + 
        ggtitle(paste0("Frequency of ", x, "-grams"))
}

plot_ngram_frequency(2)
plot_ngram_frequency(3)
```








